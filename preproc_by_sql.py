# Preprocessing of data done by SQL queries

import csv
from sqlalchemy import create_engine
import pandas as pd
import sys
import json

def leave_intact_subquery(columns):
    return ', '.join(['%(s)s AS "%(s)s"' % {'s': column} for column in columns]), [], ''

def cast_numeric_subquery(columns):
    return ', '.join(['CAST(%(s)s AS numeric) AS "%(s)s"' % {'s': column} for column in columns]), [], ''

def fill_05_subquery(columns):
    return ', '.join(['(CASE WHEN %(s)s IS NULL THEN 0.5 ELSE %(s)s END) AS "%(s)s"' % {'s': col}\
    for col in columns]), [], ''

def dummy_subquery(columns):
    subqueries, params = [], []
    for column in columns:
        print(column)
        distinct_vals = pd.read_sql(\
        "SELECT DISTINCT %(s)s FROM msft ORDER BY %(s)s NULLS FIRST"\
        % {'s': column}, con = engine)
        dummy_vars_names = distinct_vals.iloc[:, 0].tolist()
        subqueries.append(', '.join(\
            ['(CASE WHEN %(s)s %(eq)s THEN 1 ELSE 0 END) AS "%(s)s_%(v)s"'\
            % {'s': column, 'v': dummy,
               'eq': ('IS NULL' if dummy==None else '= %s') }\
            for dummy in dummy_vars_names]))
        params.extend(dummy_vars_names[1:] if dummy_vars_names[0]==None
            else dummy_vars_names)
    query = ', '.join(subqueries)
    return query, params, ''

def Census_ProcessorClass_subquery(column):
    return "(CASE WHEN Census_ProcessorClass='high' THEN 1 WHEN\
    Census_ProcessorClass='low' THEN 0 ELSE 0.5 END) AS \"Census_ProcessorClass\",\
    (CASE WHEN Census_ProcessorClass IS NULL THEN 0 ELSE 1 END)\
    AS \"Census_ProcessorClass_known\"", [], ''

def version_subquery(columns):
    subqueries, leftjoins = [], []
    for column in columns:
        print(column)
        subqueries.append('"%(s)s_Map".mapto AS "%(s)s"' % {'s': column})
        leftjoins.append("""
        LEFT JOIN (SELECT %(s)s, n1, n2, n3, n4, ROW_NUMBER() OVER () AS mapto
        FROM (SELECT DISTINCT %(s)s,
        CAST(SPLIT_PART(%(s)s, '.', 1) AS integer) AS n1,
        CAST(SPLIT_PART(%(s)s, '.', 2) AS integer) AS n2,
        CAST(SPLIT_PART(%(s)s, '.', 3) AS integer) AS n3,
        CAST(SPLIT_PART(%(s)s, '.', 4) AS integer) AS n4
        FROM (SELECT DISTINCT %(s)s FROM msft) "%(s)s_inner_table"
        ORDER BY n1, n2, n3, n4) "%(s)s_parsed_table") "%(s)s_Map"
        ON msft.%(s)s = "%(s)s_Map".%(s)s"""  % {'s': column})
    query = ', '.join(subqueries)
    leftjoin = ' '.join(leftjoins)
    return query, [], leftjoin


def preproc_query(engine):
    leave_intact_columns = ['MachineIdentifier', 'IsBeta', 'IsSxsPassiveMode',
        'HasTpm', 'AutoSampleOptIn', 'Census_HasOpticalDiskDrive',
        'Census_IsPortableOperatingSystem', 'Census_IsSecureBootEnabled',
        'Census_IsTouchEnabled', 'Census_IsPenCapable',
        'OsBuild', 'Census_OSBuildNumber', 'Census_OSBuildRevision']

    # Fill with 0.5
    fill_05_columns = ['IsProtected', 'SMode', 'Firewall',
        'Census_IsFlightingInternal', 'Census_IsFlightsDisabled',
        'Census_ThresholdOptIn', 'Census_IsWIMBootEnabled',
        'Census_IsVirtualDevice', 'Census_IsAlwaysOnAlwaysConnectedCapable',
        'Wdft_IsGamer']

    dummy_vars_columns = ['Census_FlightRing',
        'ProductName', 'RtpStateBitfield',
        'AVProductsInstalled', 'AVProductsEnabled',
        'Platform', 'Processor', 'OsSuite', 
        'OsPlatformSubRelease', 'SkuEdition',
        'PuaMode', 'SmartScreen', 'UacLuaenable',
        'Census_MDC2FormFactor', 'Census_DeviceFamily',
        'Census_ProcessorManufacturerIdentifier',
        'Census_OSArchitecture', 'Census_OSBranch',
        'Census_OSEdition', 'Census_OSSkuName',
        'Census_OSInstallTypeName',
        'Census_OSWUAutoUpdateOptionsName',
        'Census_GenuineStateName',
        'Census_ActivationChannel',
        'Census_PrimaryDiskTypeName']

    Census_ProcessorClass_column = 'Census_ProcessorClass'

    version_columns = ['OsVer', 'EngineVersion', 'AppVersion',
        'AvSigVersion', 'Census_OSVersion']

    funcsAndCols = [\
        (leave_intact_subquery, leave_intact_columns),
        (fill_05_subquery, fill_05_columns),
        (Census_ProcessorClass_subquery, Census_ProcessorClass_column),
        (dummy_subquery, dummy_vars_columns)]
        #(version_subquery, version_columns)]
    query, params, leftjoin = '', [], ' '
    for f, x in funcsAndCols:
        print(f.__name__)
        next_query, next_params, next_leftjoin = f(x)
        query += next_query + ', '
        params += next_params
        leftjoin += ' ' + next_leftjoin
    
    query = query[:-2] + ' FROM msft' + leftjoin
    return query, params    


def save_query_template(engine, query_template_filename='query_template.txt'):
    query, params = preproc_query(engine)
    query_json = json.dumps({'query': query, 'params': params})
    with open(query_template_filename, 'w') as f:
        f.write(query_json)


def preproc_train(engine, query_template_filename='query_template.txt', N=100):
    with open('query_template.txt', 'r') as f:
        row = f.read()
        query_template = json.loads(row)
    params = query_template['params']
    query = 'SELECT HasDetections AS "HasDetections", %s' % query_template['query']

    # df = pd.read_sql(query, params=params, con=engine)
    # df.to_csv('preproc_train.csv', quoting=csv.QUOTE_NONNUMERIC)
    # df.to_pickle('preproc_train.pkl')


    columns = pd.read_sql(query + ' LIMIT 0', params=params, con=engine)
    columns = columns.columns.tolist()
    print(columns)

    sql_query = engine.execute(query\
        + ' WHERE HasDetections IS NOT NULL'
        + (';' if N==None else\
        ' ORDER BY RANDOM() LIMIT %d;' % N),
        params)
    print('query done')
    with open('preproc_train.csv', 'w') as f:
        writer = csv.writer(f, quoting=csv.QUOTE_NONNUMERIC)
        writer.writerow(columns)
        sql_query = engine.execute(query, params)
        for row in sql_query:
            writer.writerow(row)

if __name__=='__main__':
    engine = create_engine('postgresql+psycopg2://petr:abc123@localhost/msft')
    save_query_template(engine)
    #preproc_train(engine)
